<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Как убедиться, что техническое решение нужно? &middot; 
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- latex support -->
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();
     for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
     k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(97974293, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/97974293" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>


  <body class="theme-base-00">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          
        </a>
      </h1>
      <p class="lead"><a href="https://t.me/pepegramming" target="_blank">2pegramming</a></p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Главная</a>

      <a class="sidebar-nav-item" href="/blogposts">Посты</a>
      <!-- <a class="sidebar&#45;nav&#45;item" href="/streams">Стримы</a> -->
      <!-- <a class="sidebar&#45;nav&#45;item" href="/questions">Ответы на вопросы</a> -->
      <a class="sidebar-nav-item" href="https://goo.gl/forms/iUd1Gufq6WnTsaO62">Обратная связь</a>
      <a class="sidebar-nav-item" href="http://github.com/2pegramming">GitHub</a>
    </nav>

    <p>&copy; 2024. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="question">
  <h1 class="question-title">Как убедиться, что техническое решение нужно?</h1>
  <span class="question-date">27 Sep 2024</span>

  <div class="message">
    <p>Этот пост является ответом на вопрос из канала <a href="https://t.me/pepegramming/">pepegramming</a>. Если увидите неточность или захотите что-то добавить – буду рад комментариями в канале.</p>
    <p>Если нашли опечатку – <a href="https://github.com/2pegramming/2pegramming.github.io/tree/master/questions/_posts">можно отправить PR с исправлениями</a></p>
  </div>

  <hr>

  <ul><li><a href="#вопрос">Вопрос</a><ul><li><a href="#эволюция-системы">Эволюция системы</a></li><li><a href="#смотрим-шире">Смотрим шире</a><ul><li><a href="#пример-описания-решения-с-анализом-надсистем-и-без">Пример описания решения с анализом надсистем и без</a></li></ul></li><li><a href="#как-провалидировать-техническое-решение">Как провалидировать техническое решение</a></li><li><a href="#советы">Советы</a><ul><li><a href="#на-какие-надсистемы-стоит-обратить-внимание">На какие надсистемы стоит обратить внимание</a></li><li><a href="#что-делать-если-нет-времени-отвечать-на-вопросы-а-техническое-решение-нужно-было-еще-вчера">Что делать, если нет времени отвечать на вопросы, а техническое решение нужно было еще вчера</a></li><li><a href="#что-делать-если-в-компании-плевать-и-надо-быстро-без-времени-на-подумать">Что делать, если в компании плевать и надо быстро без времени на подумать</a></li><li><a href="#что-делать-если-другие-разработчики-не-хотят-так-заморачиваться-а-хотят-обсуждать-новые-сервисытехнологии">Что делать, если другие разработчики не хотят так заморачиваться, а хотят обсуждать новые сервисы/технологии</a></li></ul></li><li><a href="#выводы">Выводы</a></li><li><a href="#ссылки">Ссылки</a></li></ul></li></ul>

  <h2 id="вопрос">Вопрос</h2>

<div class="question-text">
  <blockquote>
    <p>Разработчики (или другая команда) пришли с техническим решением. Как понять, что решение нужно?</p>
  </blockquote>
</div>

<p><em><strong>TLDR</strong>: чтобы оценить техническое решение, нужно убедиться, что решение описывает текущее состояние системы, желаемое состояние и путь по которому пройдет эволюция. А также учитывает надсистемы – пользователей, бизнес и другие процессы. Если описание решения не охватывает эти аспекты, решение стоит доработать</em></p>

<p>Можно было бы ответить, что надо, чтобы техническое решение было описано по заветам ADR (либо RFC), а разработчики понимали что будут делать. На деле, такой ответ бессмысленный, так как в decision record можно написать способ реализации решения, но не объяснить почему решение нужно и как решение связано с проблемой бизнеса (далее рассмотрим реальный пример).</p>

<p>Еще одно уточнение: тема супер обширная и глубокая. Чтобы подробно ответить на вопрос, придется написать еще одну книгу (а таких книг много: <a href="http://fundamentalsofsoftwarearchitecture.com" target="_blank">первая</a>, <a href="https://www.manning.com/books/architecture-modernization" target="_blank">вторая</a>, <a href="https://www.oreilly.com/library/view/software-architecture-the/9781492086888/" target="_blank">третья</a>, <a href="https://www.oreilly.com/library/view/software-architecture-and/9780138249694/" target="_blank">четвертая</a>, <a href="https://www.georgefairbanks.com/book/" target="_blank">пятая</a>, <a href="https://www.oreilly.com/library/view/economics-driven-software-architecture/9780124104648/" target="_blank">шестая</a>  и так далее). К тому же, не буду описывать как подготовить решение на валидацию, потому что это на отдельный междисциплинарный курс тянет и ответ написать такого размера не представляется возможным.</p>

<p>Поэтому, в ответе на вопрос решил рассказать о двух идеях, которые помогают быстро оценить насколько продумано и проанализировано предлагаемое решение.</p>

<h3 id="эволюция-системы">Эволюция системы</h3>

<p>Под системой подразумеваю набор связанных элементов (и свойства системы и каждого элемента). При этом, функциональность системы превышает сумму отдельных элементов (читай <a href="https://en.wikipedia.org/wiki/Emergence" target="_blank">эмерджентность</a>. А как пример - песочные часы, которые показывают сколько времени прошло, но песок и стекло, по отдельности, подобного не могут).</p>

<p>Если рассматривать что угодно как систему, то получается, что возникает причина, в которой старая система перестает работать так, как ожидается. Следовательно, нужно изменить систему так, чтобы новая система снова начала работать корректно для новой ситуации. Т.е. эволюционировать из текущей точки А в требуемую точку Б. Причем не важно, переписываете систему целиком, либо добавляете функционал – это будет новая система в новой точке (проблему <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%B0%D0%B1%D0%BB%D1%8C_%D0%A2%D0%B5%D1%81%D0%B5%D1%8F" target="_blank">корабля Тесея</a> оставим для другого ответа).</p>

<p>Такое изменение системы под новые требования идейно похоже на путешествие из точки А в точку Б. Только вместо перемещения людей в пространстве, перевозим «систему» во времени и функционале.</p>

<figure class="image">
  <img src="/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/system-evolution-base.jpeg" alt="dbml: code and visualisation" />
  <figcaption><p>Если песочные часы отсчитывали 5 минут, то для 10 минут придется увеличивать количество песка, т.е. эволюционировать систему из точки А в точку Б</p>
</figcaption>
</figure>

<p>За примерами далеко ходить не надо: </p>
<ul>
  <li>Делаем онлайн магазин (точка А), наступил ковид, пришли пользователи – система не справляется. Можем как масштабировать систему горизонтально, а можем навесить кеширования (точка Б);</li>
  <li>Делаем таск трекер для компаний (точка А), но клиенты резко начали использовать новую методологию работы, которую трекер не поддерживает. Нужно сделать так, чтобы трекер мог работать с новым UberAgile, иначе клиенты уйдут к конкурентам. Можем как добавлять новый функционал, так и переписывать текущий, под новые требования (точка Б);</li>
  <li>Делаем онлайн игру (точка А), но люди отваливаются через час игры. Можем как наваливать новых механик, так и улучшать уже реализованные (точка Б);</li>
</ul>

<p>При этом, эволюцию, которая не приводит систему к нужному состоянию, сложно назвать «полезной» и корректной. Например, хотим увеличить количество пользователей в стартапе. Для этого желательно, чтобы фичи появлялись как можно быстрее, а технический отдел предлагает разбить монолит на 10 сервисов руками двух из трех разработчиков. В результате фичи делать некому, деньги ресурсы тратятся непонятно на что, а time to market улетает в небо.</p>

<figure class="image">
  <img src="/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/system-evolution-reality.jpeg" alt="dbml: code and visualisation" />
  <figcaption><p>Хотели быстрее добавлять фичи в систему (точка Б), но по итогу пять лет мучаемся с распилом монолита на сервисы (точка С)</p>
</figcaption>
</figure>

<p>Чтобы такой ситуации не возникло, придется разобраться с тремя проблемами: какая система до момента эволюции, какой система будет после эволюции и как будет происходить процесс. А для этого придется ответить на ряд вопросов (вопросы абстрактные, нужны больше для примера):</p>

<p><strong>Вопросы связанные с системой в текущем моменте (точка А):</strong></p>
<ul>
  <li>Из чего состоит текущая система и какие связи между элементами?</li>
  <li>Какие свойства у текущей системы? (SLA, выдерживаемая нагрузка, скорость добавления фичей и так далее);</li>
</ul>

<p><strong>Вопросы связанные с будущем видом системы (точка Б):</strong></p>
<ul>
  <li>Какие новые свойства должны быть у системы и почему эти свойства важны?</li>
  <li>Как должна выглядеть новая система с новыми свойствами (элементы связи)?</li>
  <li>Как изменятся текущие свойства системы?</li>
  <li>Какие риски могут произойти после эволюции?</li>
</ul>

<p><strong>Вопросы связанные с переходом из точки А в Б:</strong></p>
<ul>
  <li>Какие способы перейти из точки А в точку Б существуют?</li>
  <li>Какие потенциальные риски возникнут во время перехода?</li>
</ul>

<h3 id="смотрим-шире">Смотрим шире</h3>

<p>Когда разработчики предлагают технические решения, часто решение рассматривает проблему исключительно с точки зрения технической системы (кода, инфраструктуры и алгоритмов реализации). Даже накину, что подобное отношение к принятию решений быстрее приведет систему к «легаси», чем отсутствие технических компетенций в команде.</p>

<p>Чтобы избежать подобной «ловушки», придется прибегнуть к системной инженерии и концепции систем, подсистем и надсистем. Если коротко, создали код в репозитории, но код не крутиться в вакууме. Т.е. есть люди, которые этот код пишут (или просят gpt написать код), используют задеплоенное приложение, а есть бизнес, который нанял людей, чтобы написанный код закрывал потребности бизнеса. Группы людей и бизнес – такие же системы, находящиеся «над» рассматриваемой технической системой.</p>

<p>При этом, если говорим о software systems, то тут над систем будет больше двух. Например, <a href="https://cs.ccsu.edu/~stan/classes/CS530/Notes18/19-SystemsEngineering.html" target="_blank">в интернете можно найти такую картинку</a>:</p>

<figure class="image">
  <img src="/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/software-system-as-system-of-systems.png" alt="dbml: code and visualisation" />
  <figcaption><p>Техническая система – часть большей надсистемы связанной с организацией. А организация – подсистема для еще одной надсистемы, связанной с целями и стратегиями бизнеса и так далее</p>
</figcaption>
</figure>

<p>Если слышали о правиле, которое упоминается в системной инженерии – смотреть на надсистемы рассматриваемой системы. В случае кода – это когда рассматривается не только код в репозитории, но надсистемы: работающее приложение, бизнес, сотрудников с их подходами к знаниями и так далее.</p>

<p>Тут момент: иногда надсистемой является техническая система, если рассматриваемая система – часть технической системы, например сервисы или модули. Например, один раз рассматривал решение с выносом информации о используемых валютах в компании в отдельный сервис. Разработчик решал проблему только в рамках одного bounded context, но информация о валютах использовалась еще в четырех контекстах. На вопрос, как остальные четыре контекста будут работать – ответа не было. Т.е. даже в рамках технической системы можно сконцентрироваться на одной подсистеме (например паре сервисов) и не рассматривать техническую систему как надсистему.</p>

<figure class="image">
  <img src="/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/technical-subsystem.jpeg" alt="dbml: code and visualisation" />
  <figcaption><p>В данном случае сервис S3 будет подсистемой (subsystem) для technical system, но сервис S3 можно рассматривать как отдельную систему с надсистемой в виде technical system</p>
</figcaption>
</figure>

<p>Давайте на примерах из прошлой секции рассмотрим как изучение надсистемы может повлиять на решения проблем:</p>

<ul>
  <li>Делаем онлайн магазин, наступил ковид, пришли пользователи – система не справляется. Тут проблема может оказаться как в техническом решении (страница не открывается), так и проблема с сотрудниками (не хватает курьеров и собирателей заказов);</li>
  <li>Делаем таск трекер для компаний, но клиенты резко начали использовать новую методологию работы, которую трекер не поддерживает. Если смотреть на техническую систему – решением будет добавить новый функционал или изменить существующий. Если смотреть на надсистему – может оказаться, что хайповый инструмент не решает проблем компаний и нужно вкладываться в обучение и объяснения, почему уже реализованные подходы в таск трекере лучше;</li>
  <li>Делаем онлайн игру, но люди отваливаются через час игры. Технически можно пилить контент или улучшать уже реализованный. А если смотреть выше – окажется, что хватит раз в месяц разыгрывать новый айфон за первые три места в дашборде лидеров;</li>
</ul>

<p>Этот рассказ о надсистемах нужен только для одной идеи, в рамках ответа: проблемы, которые, на первый взгляд, можно закрыть технически – не всегда стоит закрывать на уровне technical system. Иногда можно подняться выше (разобравшись в надсистеме) и найти решение там, не тратя деньги на дорогой (во всех смыслах) технический отдел. Из-за этого, чтобы понять на сколько «нужно» решение, придется разобраться, было бы проанализировано решение, вне технических изменений.</p>

<figure class="image">
  <img src="/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/tech-business-changes-tradeoff.jpeg" alt="dbml: code and visualisation" />
  <figcaption><p>Иногда проще поменять бизнес или надсистемы, чем что-то делать с кодом в виду стоимости разработки (считаем зп людей, которые будут разрабатывать и поддерживать код)</p>
</figcaption>
</figure>

<p>Чтобы понять что изменение в технической системе нужно, стоит проверить две вещи:</p>

<ol>
  <li>Проверить, что изменение технической системы будет дешевле чем исправление надсистемы. В случае с играми, разыгрывать 3 айфона в месяц (~3600$ за три iPhone 16 pro max + логистика) дешевле, чем тратить даже месяц разработки одной команды (считал для связки из одного тимлида, 2 мидлов и одного дизайнера);</li>
  <li>Проверить, что новая система вписывается в надсистемы выше. Так, если во время наплыва пользователя, доставка не справляется из-за количества людей, ускорение главной страницы не спасет, но ресурсы на разработку будут потрачены;</li>
</ol>

<p>Вообще, эту муть с надсистами можете заметить в постах, где от разработчиков «просят» смотреть не только на код, но и на бизнес с его потребностями/проблемами. Например, <a href="https://t.me/pmdaily/1196" target="_blank">Федя пишет об этом же</a>, только без зауми вокруг системной инженерии.</p>

<p>Может показаться, что подобными вещами должны заниматься продукты и бизнес, но давайте на примере двух «одинаковых» ADR посмотрим как это работает с техническими изменениями.</p>

<h4 id="пример-описания-решения-с-анализом-надсистем-и-без">Пример описания решения с анализом надсистем и без</h4>

<p>В самом начале я упомянул, что использование «фреймворков» для описания решений не поможет, так как проблема не в структуре, а в содержании. В качестве примера, давайте рассмотрим два ADR из двух архитектурных кат. Оба документа связаны с кешированием.</p>

<p>В примере рассмотрим только секцию с контекстом так как эта часть ADR, которая отвечает за объяснение проблемы, а без понимания проблемы – решение бессмысленно. Попробуйте ответить на вопрос: какой из двух контекстов лучше объясняет причину, почему было решено использовать кеширование. И почему один из двух документов справляется с объяснением причины использования кэширования лучше.</p>

<p><a href="https://github.com/kamikazeSlayers/architectural-katas-2022/blob/main/adrs/adr06-caching.md" target="_blank">Первый ADR</a>:</p>

<blockquote>
  <p>Ease of use of the Spotlight app is one of the primal requirement for its success. Page load time is an important criteria that determines the quality of the end user experience. To this avail, Spotlight app utilizes caching for almost all its entities.</p>

  <p>Caching is a common architectural paradigm that not only helps reduce the page-load time, but also help in retrieving data efficiently without loading the critical infrastructure in the system.</p>

  <p>‘Cache Manager’ micro-service consumes all entity updates via the message bus and updates the in-memory cache. This provides an efficient way to manage cache entities, populate cache on demand.</p>
</blockquote>

<p><a href="https://github.com/ldynia/archcolider/blob/master/4.ADRs/013%20%20Cache%20the%20meal%20catalogue.md" target="_blank">Второй ADR</a>:</p>

<blockquote>
  <p>User satisfaction and speed of the application is our priority and in case of a slow\unstable connection, we’d like to have the smallest delay possible in catalog browsing. Users expect quick response times. We can safely assume that the menu catalog won’t have drastic changes during a day and we can cache the catalog with an estimated number of meals in each fridge in the user’s area. Most probably the whole menu can be formed for a week and provided for the ordering system. Based on this assumption we could upload the meal catalog once per day with the amount of available Stock Keeping Unit (SKU) in fridges. Our estimations on the update package sizes show that a catalog with 20 meals could weigh around 500kb-700kb without images. Even if it might not be a significant amount of data for a single entry, multiplying it by the number of users gives us a large amount of data to transfer which isn’t free for us and the users. The catalog updates with a meal amount might be organized as additional event messages that will be very lightweight compare to the entire catalog that will save us money on the Cost of Ownership. So we can upload this information upfront.</p>

  <p>The purchase process, i.e. payment confirmation, always takes some time and users get used to it and this can be used to attempt to actualize a certain position in the menu.</p>
</blockquote>

<p>Если выкинуть воду из первого ADR и оставить только объяснение причины из-за которой необходимо добавить кеш, то выйдет что бизнесу зачем-то нужна простота использования (ease of use) и время загрузки почему-то важный критерий для этого. При этом, сразу выбирается кеширование (а не in memory DB, например или другая тактика) и дальше начинается техническое описание вокруг инфры, сервисов и прочего. Т.е. автор первого документа проваливается в описание технического решения только в рамках technical system, не описывая проблематику с позиции бизнеса и пользователей (надсистем).</p>

<p>Во втором контексте описание идет со стороны бизнеса и пользователей (надсистем): описывается проблема бизнеса с удовлетворенностью пользователей, описывается поведение пользователей, после чего уже идет переход к предположению, что кеш поможет, и то, не в контексте реализации, а в контексте требований к решению.</p>

<p>Если учесть, что цель АДР – описать проблему, в которой решение принималось, то открыв первый документ через 3 года, возникнут вопросы: «почему появился кэш». В случае второго документа – конкретики станет больше и через три года, когда вернетесь к АДР, станет понятно, почему появилась идея добавить кэширования, которое постоянно ломается.</p>

<h3 id="как-провалидировать-техническое-решение">Как провалидировать техническое решение</h3>

<p>Если объединить две идеи, получим «правило» валидации технического решения: проверить, что авторы решения подумали как об эволюции (место старта, куда придем и как будем двигаться), так и о том, как решение связано и будет вписано в другие надсистемы. Поэтому, для валидации решения, ищу ответы на вопросы вокруг эволюции, связанные как с технической системой, так и с надсистемами.</p>

<p>Сам список выглядит так (возможно часть вопросов пропустил, но цель донести идею):</p>

<p><strong>Вопросы связанные с системой в текущем моменте (точка А):</strong></p>

<p>Вопросы к технической системе:</p>
<ul>
  <li>Из каких элементов состоит система или часть системы, в которой будут изменения?</li>
  <li>Какие связи между элементами и как связи работают?</li>
  <li>Какие свойства у текущей системы? (это о SLA, перфомансе, секьюрити и других quality attributes/NFR/architectural characteristics)</li>
  <li>Почему текущая система перестала удовлетворять требованиям?</li>
  <li>Какие места системы не удовлетворяют требованиям?</li>
</ul>

<p>Вопросы к надсистемам:</p>
<ul>
  <li>Почему бизнесу необходимы новые свойства от системы?</li>
  <li>Кто из characteristics заинтересован в изменениях и почему?</li>
  <li>Какие потребности стейкхолдеров первичны, а какие вторичны?</li>
  <li>Кто из исполнителей свободен и какие компетенции нужны для эволюции?</li>
  <li>Какими ресурсами располагает компания момент эволюции и что из этого можно выделить на изменения?</li>
</ul>

<p><strong>Вопросы связанные с будущим видом системы (точка Б):</strong></p>

<p>Вопросы к технической системе:</p>
<ul>
  <li>Какие <a href="https://systems.education/biz-req#rec229738249" target="_blank">solution requirements</a> к новой системе?</li>
  <li>Какие решения для эволюции системы рассматриваются под новые требования?</li>
  <li>Какие свойства будут у итоговой системы при каждом варианте изменений? (нужно, чтобы понять на сколько близко система будет к точке Б);</li>
  <li>Какой из вариантов новых систем удовлетворяет потребности лучше и почему?</li>
  <li>Что может пойти не так в новой системе?</li>
</ul>

<p>Вопросы к надсистемам:</p>
<ul>
  <li>Какие бизнес процессы будут затронуты изменением?</li>
  <li>На сколько критичные части бизнеса будут затронуты новой системой? (виды поддоменов из ДДД, либо value chain + commoditization из карт вордли, либо другой способ понимания важности элементов бизнеса);</li>
  <li>Какие потребности заинтересованных сторон будут закрыты при каждом из решений?</li>
  <li>Как изменения повлияют на надсистемы? (тут и о людях, бизнесе, и другие части технической системы);</li>
  <li>Что дешевле, реализовать решение или оставить текущую систему без изменений?</li>
  <li>Частный случай вопроса выше – какие интеграции надо будет добавить, изменить или удалить?</li>
</ul>

<p><strong>Вопросы связанные с переходом из точки А в Б:</strong></p>

<p>Вопросы к технической системе:</p>
<ul>
  <li>Как произвести изменения в лучшем из вариантов и сколько это будет стоить?</li>
  <li>Что может пойти не так во время изменений?</li>
  <li>Как убедиться, что итоговая система будет удовлетворять новым требованиям? (например: тесты и fitness functions);</li>
</ul>

<p>Вопросы к надсистемам:</p>
<ul>
  <li>Какие риски, связанные с надсистемами, могут возникнуть (кончатся деньги, не будет специалистов, требования потеряют актуальность и так далее);</li>
  <li>Сколько стоит решение? Не обязательно считать в деньгах, хватит и человеко-часов, даже примерных;</li>
  <li>Был ли составлен хайлевел план эволюции для задействованных команд, кто будет работать над эволюцией? <a href="https://pepegramming.site/questions/graph-as-a-project-managment-tool/" target="_blank">Хотя бы в общих чертах</a>;</li>
</ul>

<p>Если из описания нельзя получить ответы на вопросы выше – задаю вопросы лично и после решаю на сколько авторы понимают что делают. Вопросов можно придумать бесконечное количество, но тут важнее убедиться, что во время принятия решения авторы прошли полный путь анализа и синтеза. Т.е. могут рассказать как о текущем состоянии системы, так и том, куда и почему система будет идти и как это связано как с бизнесом, так и с людьми которые будут делать изменения, использовать систему и поддерживать систему в будущем.</p>

<p>Если видно, что решение описывает только техническую реализацию и не понятно от куда и почему решение взялось, то решение придется отклонить или попросить доделать (либо помочь с переделкой).</p>

<p>Понимаю, что на вопросы только разработчики ответить не смогут, поэтому стоит обращаться к аналитикам, продуктам или другим людям, которые помогут с ответами.</p>

<h3 id="советы">Советы</h3>

<h4 id="на-какие-надсистемы-стоит-обратить-внимание">На какие надсистемы стоит обратить внимание</h4>

<p>Можно встать в ступор, если с нуля пытаться определить надсистемы, о которых стоит думать. Чтобы жилось проще, напишу список систем о которых сам думаю, когда принимаю технические решения:</p>

<ul>
  <li><strong>Hardware</strong>. Наличие ресурсов, возможность развернуть новые базы либо сервисы, по сути инфраструктурные вопросы;</li>
  <li><strong>Внешние зависимости</strong>. Как долго будут поддерживать библиотеки или SaaS, сколько будет стоить переезд, если зависимость отвалится (или покинет рынок), сколько времени будет стоит обучение сотрудников использованию зависимости и так далее;</li>
  <li><strong>Сотрудники компании</strong>. С кем связано решение, сколько человек готовы работать над изменениями, какие людские компетенции в наличии у компании и надо ли проводить обучение, на сколько люди выгорели или устали, какая мотивация работать над изменениями и так далее;</li>
  <li><strong>Организационная структура</strong>. В отличии от сотрудников, тут рассматривается структура организации: разделены команды фронтов от бека, как быстро работает команда инфраструктуры, соответствуют отделы бизнеса bounded context-ам или subdomain, существует ли команда для DX и точечной работы над сложными тех решениям. <a href="https://teamtopologies.com" target="_blank">Team topology</a> – как пример подхода, который фокусируется на данной надсистеме при решении архитектурных проблем;</li>
  <li><strong>Бизнесовые процессы</strong>. Какие процессы будут аффектиться решением, какие процессы меняются часто, а какие медленно, на сколько кодовая структура соотносится с «элементами» бизнес процессов (тут о <a href="https://www.domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf" target="_blank">стратегическом DDD</a>, <a href="https://learnwardleymapping.com" target="_blank">wardley mapping</a>) и так далее;</li>
  <li><strong>Бизнес</strong>. Какие стратегические цели у бизнеса в контексте квартала, года и пары лет, какие проблемы решает бизнес, какие ограничения у бизнеса на момент эволюции и так далее;</li>
  <li><strong>Внешние ограничения</strong>. Юридические ограничения в конкретной стране, что с налогами и спецификой страны, в которой работает бизнес;</li>
  <li><strong>Доменная модель</strong>. Спорная «надсистема», но идея в том, что у каждой доменной модели присутствуют ограничения или подходы к работе. Лучше поговорить с экспертом или почитать книги о домене;</li>
</ul>

<h4 id="что-делать-если-нет-времени-отвечать-на-вопросы-а-техническое-решение-нужно-было-еще-вчера">Что делать, если нет времени отвечать на вопросы, а техническое решение нужно было еще вчера</h4>

<p>К сожалению, тут нет одного алгоритма и контекст ситуации важен:</p>

<ul>
  <li>Если говорим о стартапе, где нет денег, сотрудников и времени, то намного важнее искать прибыльные гипотезы. Следовательно, стоит забить на дотошный анализ проблем и делать как делается. А в будущем уже исправлять систему, как только появятся деньги и ресурсы для этого;</li>
  <li>Если говорим о бизнесе, в котором надо срочно починить баг, из-за которого теряются деньги – ситуация аналогичная. Быстро фиксим, пишем постмортем (если ситуация критичная). После, разбираемся как изменить систему, чтобы было ок;</li>
  <li>Если говорим о локальных изменениях в рамках бизнес процесса, модуля (или класса), сервиса или другой изолированной части системы – тут возникает трейдофф, между качеством и ценой решения. В случае <a href="https://vladikk.com/2018/01/26/revisiting-the-basics-of-ddd/" target="_blank">core subdomain</a> траты на дотошный анализ решений скорее окупятся, в рамках support или generic – нет;</li>
  <li>Если говорим об изменениях, затрагивающих большую часть технической системы и компания перешла стадию «делаем как угодно, главное денег получить», то тут советую потратить пару дней на анализ. Связано это с тем, что подобная «трата времени» приведет к <a href="https://fs.blog/second-order-thinking/" target="_blank">мышлению второго порядка</a>, что удешевит техническую составляющую бизнеса. А как это «продать» бизнесу – обсудим ниже;</li>
</ul>

<h4 id="что-делать-если-в-компании-плевать-и-надо-быстро-без-времени-на-подумать">Что делать, если в компании плевать и надо быстро без времени на подумать</h4>

<p>Тут как и в прошлом совете, зависит от контекста. Иногда встречаются ситуации, когда нет смысла объяснять, так как бизнес сам все понимает:</p>

<ul>
  <li><strong>Если стартап, то делайте как делается, исправлять потом будете</strong> (если будет что исправлять). Но как совет – изолируйте фичи на уровне кода (модули, классы и так далее). Нужно это, чтобы избежать god objects и «спайки» процессов бизнесовых;</li>
  <li><strong>Авральная ситуация</strong>. Кончились деньги, наступил ковид, квантовые компьютеры сломали криптографические ключи и так далее. В таком случае скорость изменений важнее качества системы;</li>
  <li><strong>Бизнесу действительно не нужно «техническое качество»</strong>. Встречаются ситуации, когда бизнес пилит средства инвесторов, либо начинается саботаж. Узнается после общения с бизнесом. В таком случае, можно технические решения не проверять (а лучше избегать подобных компаний);</li>
</ul>

<p>Но если говорим о ситуации, когда в компании все хорошо, то тут придется «продавать» подход. Обычно хватает объяснения через «систему» в которой мыслит бизнес. Т.е. нет смысла продавать анализ потому что так посоветовали в интернете. Вместо этого стоит объяснить, что качество технической системы увеличится, что приведет к большему соответствию требованиям и меньшему количеству переделок после релиза (тут индивидуальные причины для каждой ситуации). Подробнее о продаже советую почитать во второй ссылке, в конце ответа.</p>

<p><strong>Важно</strong>: учтите, что «важное или полезное» для бизнеса =/= «важное или полезное» для инженеров. Связано это с тем, что «бизнес» видит больше не технических проблем и там другие приоритеты. Лично видел (и сам сталкивался), как подобная ситуация загоняет разработчиков в депрессию, потому что кажется, что потратить месяц на ускорение страницы на 100мс необходимо, а у бизнеса кончились деньги, нет продаж и еще конкуренты давят. Вот тут как раз еще один пример когда изучение надсистем позволит справится с подобными ситуациями.</p>

<h4 id="что-делать-если-другие-разработчики-не-хотят-так-заморачиваться-а-хотят-обсуждать-новые-сервисытехнологии">Что делать, если другие разработчики не хотят так заморачиваться, а хотят обсуждать новые сервисы/технологии</h4>

<p>Сложный для меня кусок ответа, так как стараюсь избегать тем, связанных с управлением и взаимодействием с людьми. Если бизнес согласен тратить время на детальный анализ решений, то можно влиять на других. Если бизнес не готов тратить ресурсы, то тут сложнее. Можно продавать подобное описание решений как <a href="https://ailev.livejournal.com/1513051.html" target="_blank">мышление письмом</a>, которое позволит глубже в проблеме разобраться. Плюс это навык за который платят выше (ну и прокачка себя как инженера, а не кодера).</p>

<p>Но советую показывать на собственном примере, а не давить окружающих дополнительной работой. Т.е. начните описывать собственные решения подобным образом, если люди увидят пользу, то будут повторять.</p>

<h3 id="выводы">Выводы</h3>

<p>Не важно, сами предлагаете решение или принесли решение на валидацию из вне. Важно обратить внимание на две вещи: надсистемы (бизнес, людей, технологии, интеграции и так далее) и три этапа эволюции (точка А, точка Б и путь от А к Б). </p>

<p>Хоть концепции и не дают 100% гарантии, что решение будет корректным, но такой анализ позволит глубже понять проблему, что приблизит к поиску наиболее подходящего решения. При этом, подобная работа увеличивает стоимость решения, что может быть вредно для бизнеса «без денег» и другим людям. Но если необходимо изменить критически важную часть системы и переживаете о долгосрочных проблемах – стоит попробовать самостоятельно, а после «продавать» остальным.</p>

<h3 id="ссылки">Ссылки</h3>

<ul>
  <li>[en] Урок из курса по системной инженерии, в котором <a href="https://cs.ccsu.edu/~stan/classes/CS530/Notes18/19-SystemsEngineering.html" target="_blank">рассказывается о socio-technical systems</a>. Причем упор делается на software systems, так как подобные системы – социо-технические. Советую ознакомиться, потому что ответ копирует часть материала из ссылки;</li>
  <li>[ru] Ссылка, на которую сослался в описании продажи решений бизнесу. <a href="http://agilemindset.ru/аргументация-технических-решений/" target="_blank">Автор описывает как аргументировать технические решения</a>;</li>
  <li>[ru] Если первая ссылка рассказывает о socio-technical системах, то тут <a href="https://libraryno.ru/1-tehnicheskaya-sistema-sistemnyy-podhod-dolotov/" target="_blank">глава учебника, в которой рассказывается о системах, подсистемах и надсистемах</a>.</li>
  <li>[en] Затронул <a href="https://fs.blog/second-order-thinking/" target="_blank">мышление второго порядка</a> в ответе. Подход напоминает, что стоит выбирать решения не по прямому результату, а по последствиям, которые появятся от решения. Так, не самое корректное решение, может оказаться предпочтительнее в будущем;</li>
</ul>


  <hr>

  <p>Нашли опечатку или ошибку? Буду рад <a href="https://github.com/2pegramming/2pegramming.github.io/tree/master/questions" target="_blank">PR-у</a>.</p>
</div>

<!-- <div class="related"> -->
<!--   <h2>Related Posts</h2> -->
<!--   <ul class="related&#45;posts"> -->
<!--      -->
<!--       <li> -->
<!--         <h3> -->
<!--           <a href="/questions/system-evolution-prediction/"> -->
<!--             Как «предсказать» какой система окажется в будущем -->
<!--             <small>18 Nov 2024</small> -->
<!--           </a> -->
<!--         </h3> -->
<!--       </li> -->
<!--      -->
<!--       <li> -->
<!--         <h3> -->
<!--           <a href="/questions/how-to-map-eventstorming-to-code/"> -->
<!--             Как перевести EventStorming модель в код -->
<!--             <small>11 Oct 2024</small> -->
<!--           </a> -->
<!--         </h3> -->
<!--       </li> -->
<!--      -->
<!--       <li> -->
<!--         <h3> -->
<!--           <a href="/questions/how-i-use-obsidian-and-why/"> -->
<!--             Как и почему использую Obsidian -->
<!--             <small>14 Sep 2024</small> -->
<!--           </a> -->
<!--         </h3> -->
<!--       </li> -->
<!--      -->
<!--   </ul> -->
<!-- </div> -->

    </div>

  </body>
</html>
